<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Feymann"><title>NodeJS事件循环 · Feymann</title><meta name="description" content="事件循环process是计算机执行的最小实例。一个process可以有多个threads，OS调度负责线程和进程的资源分配。
什么是事件循环？事件循环是Event-Driven Architecture的一种实现机制。EDA广泛应用于各种服务中，比如GUI编程、Redis、Nginx等.

什么是事"><meta name="keywords" content="Blog, web, fullstack, Typescript"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 7.0.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:127px;"><h3 title=""><a href="/">Feymann</a></h3><div class="description"><p>A programmer</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/wydumn"><i class="fa fa-github"></i></a></li></ul><div class="footer"><div class="p"> <span>©  </span><i class="fa fa-star"></i><span> Feymann</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>NodeJS事件循环</a></h3></div><div class="post-content"><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>process是计算机执行的最小实例。一个process可以有多个threads，OS调度负责线程和进程的资源分配。</p>
<h4 id="什么是事件循环？"><a href="#什么是事件循环？" class="headerlink" title="什么是事件循环？"></a>什么是事件循环？</h4><p>事件循环是Event-Driven Architecture的一种实现机制。EDA广泛应用于各种服务中，比如GUI编程、Redis、Nginx等.</p>
<blockquote>
<p><a href="%5B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%EF%BC%9F%5D(https://www.redhat.com/zh/topics/integration/what-is-event-driven-architecture)">什么是事件驱动架构 ?</a></p>
</blockquote>
<p>事件循环通常包含三个部分：Event Loop、Event Queue、Event Handler.</p>
<p><img src="/images/eloop/eloop.png"></p>
<p>开启一个线程，初始化Event loop，从事件队列中取出事件，执行相应的回调函数，事件触发器不断产生不同的事件，加入事件队列，然后事件循环取出事件，执行相应的回调函数；再取下一个事件，不断重复此过程。</p>
<h3 id="NodeJS中的事件循环"><a href="#NodeJS中的事件循环" class="headerlink" title="NodeJS中的事件循环"></a>NodeJS中的事件循环</h3><p>NodeJS中的事件循环是 <strong>libuv</strong> 库实现的。[libuv](<a target="_blank" rel="noopener" href="https://docs.libuv.org/en/v1.x/">libuv documentation</a>)是一个跨平台的异步I&#x2F;O库，它提供了事件循环。</p>
<blockquote>
<p>Full-featured event loop backed by epoll, kqueue, IOCP, event ports.</p>
</blockquote>
<p><img src="https://docs.libuv.org/en/v1.x/_images/architecture.png"></p>
<h4 id="什么是事件循环？-1"><a href="#什么是事件循环？-1" class="headerlink" title="什么是事件循环？"></a>什么是事件循环？</h4><p>尽管JavaScript是单线程的，事件循环通过尽可能将操作转移到系统内核中。允许Node.js执行非阻塞I&#x2F;O操作。</p>
<p>因为现代大多数的内核是多线程的，它们可以处理在后台执行的多个操作。当某个操作完成时，内核告诉Node.js，将合适的回调加入到<strong>poll</strong>队列，最终被执行。后面我们会详细解释。</p>
<h4 id="Event-Loop解释"><a href="#Event-Loop解释" class="headerlink" title="Event Loop解释"></a>Event Loop解释</h4><p>当Node.js启动时，初始化事件循环，处理输入的代码（或者丢入REPL），代码中可能有异步的API调用，计时器，或者<code>process.nextTick()</code>，然后开始处理事件循环。</p>
<p>下图展示了一个事件循环大概的操作顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个框框都是事件循环的一个“阶段”。</p>
</blockquote>
<p>每个阶段都有一个要执行的回调函数的FIFO队列。每个阶段都是独特的。一般情况下，当事件循环进入到指定阶段，它会执行该阶段特定的操作，然后执行该阶段队列中的回调，直到队列为空或达到最大回调执行限制。之后，事件循环会进入下一阶段。</p>
<p>因为这些操作可能会调度另外的操作，所以轮询(poll)阶段处理的新事件会由<strong>内核</strong>入队，处理轮询事件时，可能会有新的轮询事件入队。长时(long running)回调使得轮询阶段运行的时间远超定时器的阈值。后面的定时器和轮询部分会详细介绍。</p>
<blockquote>
<p>在实现上，Windows和Unix&#x2F;Linux有点不同，对于解释来说不重要。最重要的部分是，实际上有7到8步，但是我们关注的是Node.js使用的、上面说的几步。</p>
</blockquote>
<h4 id="阶段概览"><a href="#阶段概览" class="headerlink" title="阶段概览"></a>阶段概览</h4><ul>
<li><p><strong>定时器</strong>：执行<code>setTimeout()</code>和<code>setInterval()</code>的回调</p>
</li>
<li><p><strong>pending 回调</strong>：执行移交给下一循环的I&#x2F;O回调</p>
</li>
<li><p><strong>idle,prepare</strong>：内部使用</p>
</li>
<li><p><strong>poll</strong>：获取新的I&#x2F;O事件；执行I&#x2F;O相关的回调（几乎所有的回调，除了close事件的回调，定时器回调，和<code>setImmediate</code>）;node会适时的阻塞</p>
</li>
<li><p><strong>check</strong>：<code>setImmediate()</code>回调执行</p>
</li>
<li><p><strong>close回调</strong>：一些’close’事件的回调，比如：<code>socket.on(&#39;close&#39;, ..)</code></p>
</li>
</ul>
<p>在每次事件循环运行中，Node.js检查是否在等待任意异步I&#x2F;O或定时器，如果没有就关掉。</p>
<h4 id="阶段详情"><a href="#阶段详情" class="headerlink" title="阶段详情"></a>阶段详情</h4><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p>定时器指定了一个<strong>阈值</strong>，在多少毫秒<em>之后可以</em>执行回调，而不是<em>期望执行</em>的<strong>确切</strong>时间。在指定时间之后，定时器的回调函数会尽早调用，但是，操作系统调度或者其他回调函数的执行可能使它们延迟。</p>
<blockquote>
<p>技术上，poll阶段控制了定时器何时执行。</p>
</blockquote>
<p>比如，你调度了一个100ms后执行的回调，然后你的脚本开始异步读取一个文件，花了95ms：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someAsyncOperation</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="title class_">Date</span>.<span class="title function_">now</span>() - timeoutScheduled;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></span><br><span class="line"><span class="title function_">someAsyncOperation</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="comment">// do something that will take 10ms...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - startCallback &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当事件循环进入<strong>poll</strong>阶段，该阶段有一个空的队列（<code>fs.readFile()</code> 还没有完成），所以还要等几毫秒，直到最近的定时器阈值到了。当在等待95ms时，<code>fs.readFile()</code> 完成了文件读取，它的回调（10ms）加入到<strong>poll</strong>队列，然后执行。当回调完成后，队列中没有了回调，所以事件循环会看看：最近的定时器阈值到了，然后回到<strong>定时器</strong>阶段，执行定时器的回调函数。在这个例子中，你会看到，定时器定都和它的回调执行之间的延迟是105ms.</p>
<blockquote>
<p>为了防止<strong>poll</strong>阶段阻塞事件循环，libuv（实现了Node.js事件循环和所有异步行为的C语言库）有硬编码的最大事件限制（依赖于系统）。</p>
</blockquote>
<h5 id="挂起回调-pending-callbacks"><a href="#挂起回调-pending-callbacks" class="headerlink" title="挂起回调(pending callbacks)"></a>挂起回调(pending callbacks)</h5><p>这个阶段执行一些系统操作的回调，比如TCP错误。举个例子，如果一个TCP socket尝试连接时接收到了<code>ECONNREFUSED</code>，一些unix系统要等待来报告错误。这就会加入到队列中，在<strong>挂起回调</strong> 阶段执行。</p>
<h5 id="轮询-poll"><a href="#轮询-poll" class="headerlink" title="轮询(poll)"></a>轮询(poll)</h5><p>轮询阶段有两个主要的功能：</p>
<ol>
<li><p>计算阻塞和I&#x2F;O轮询要花费多长时间，然后</p>
</li>
<li><p>处理轮询队列中的事件</p>
</li>
</ol>
<p>当事件循环进入到<strong>轮询</strong>阶段，没有计时器调度时，会有下面两种情况：</p>
<ul>
<li><p>如果<strong>轮询</strong>队列<strong>不为空</strong>，事件循环将同步执行队列中的回调函数，直到队列中所有回调处理完或者达到最大回调数量限制。</p>
</li>
<li><p>如果<strong>轮询</strong>队列为<strong>空</strong>，又有下面两种情况：</p>
<ul>
<li><p>如果脚本由<code>setImmediate()</code>调度，事件循环就会结束<strong>poll</strong>阶段，进入<strong>check</strong>阶段，执行这些调度的脚本。</p>
</li>
<li><p>如果没有被<code>setImmediate()</code>调度，事件循环就等待回调函数加入到队列中，然后立即执行。</p>
</li>
</ul>
</li>
</ul>
<p>一旦<strong>poll</strong>队列空了，事件循环就检查定时器，看看哪一个阈值到了。如果一个或者多个定时器就绪，事件循环就回到<strong>定时器</strong>阶段，执行那些定时器回调函数。</p>
<h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>这个阶段允许用户在<strong>poll</strong>阶段完成之后立即执行回调。如果<strong>poll</strong>阶段空闲了，脚本就入队到<code>setImmediate()</code>，事件循环可能进入<strong>check</strong>阶段，而不是等待。</p>
<p><code>setImmediate()</code>实际上是一个特殊的定时器，运行在事件循环的独立阶段。它使用了libuv API，该API调度在<strong>poll</strong>完成后执行的回调。</p>
<p>一般来说，代码执行，事件循环最终会到<strong>poll</strong>阶段，等待下一个连接、请求，等等。但是，如果回调由<code>setImmediate()</code>调度了，<strong>poll</strong>阶段就会空闲，那就会结束然后进入<strong>check</strong>阶段，而不是等待<strong>poll</strong>事件。</p>
<h5 id="close回调"><a href="#close回调" class="headerlink" title="close回调"></a>close回调</h5><p>如果一个socket或者handle突然关闭（比如，<code>socket.destroy()</code>），<code>&#39;close&#39;</code> 事件就会在这个阶段触发。否则就会由<code>process.nextTick()</code> 触发。</p>
<h5 id="setImmediate-VS-setTimeout"><a href="#setImmediate-VS-setTimeout" class="headerlink" title="setImmediate() VS setTimeout()"></a><code>setImmediate()</code> VS <code>setTimeout()</code></h5><p><code>setImmediate()</code> 和 <code>setTimeout()</code>很相似，但是根据他们调用的时机，表现出来的不一样。</p>
<ul>
<li><p><code>setImmediate()</code> 的设计是，一旦当前的<strong>poll</strong> 阶段完成了，就执行脚本</p>
</li>
<li><p><code>setTimeout()</code> 是在最小timeout时间达到后，执行脚本。</p>
</li>
</ul>
<p>定时器执行的顺序会取决于调用的上下文。如果两个都在main模块中调用，那就受进程的性能限制（被机器上其他运行的应用影响）。</p>
<p>比如，如果我们执行下面的脚本，该脚本不在一个I&#x2F;O循环内（比如，main模块），两个定时器的执行顺序就不确定，因为被进程的性能限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout vs immediate.js</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);  </span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>);  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">node timeout_vs_immediate.js</span></span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">node timeout_vs_immediate.js</span></span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>

<p>但是，如果你把两个调用移到一个I&#x2F;O循环内，immediate回调就会先执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用<code>setImmediate()</code> 的主要优势是，在一个I&#x2F;O循环内，无论有多少定时器，它的执行顺序总是优先于任何定时器。</p>
<h4 id="理解process-nextTick"><a href="#理解process-nextTick" class="headerlink" title="理解process.nextTick()"></a>理解<code>process.nextTick()</code></h4><p>你可能注意到了，<code>process.nextTick()</code>没有出现在流程图中，虽然它是异步API的一部分。这是因为<code>process.nextTick()</code>技术上不是事件循环的一部分。相反，<code>nextTickQueue</code>会在当前操作完成后处理，无论事件循环当前是在哪个阶段。在这里，一个<em>操作</em>是指从底层C&#x2F;C++ handler的转换，以及处理要执行的JavaScript.</p>
<p>再看我们的流程图，在指定阶段，任何时候你调用<code>process.nextTick()</code>，所有传给<code>process.nextTick()</code>的回调将在事件循环继续之前解析。这就会造成一些糟糕的情况，因为它允许你通过递归调用<code>process.nextTick()</code>来“饿死”你的I&#x2F;O，阻止事件循环到达<strong>poll</strong>阶段。</p>
<h4 id="为什么允许这样？"><a href="#为什么允许这样？" class="headerlink" title="为什么允许这样？"></a>为什么允许这样？</h4><p>为什么Node.js中包含了这种玩意儿？部分原因是Node.js的设计理念，一个API应该总是异步的，即使不需要是异步。以下面的代码为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">apiCall</span>(<span class="params">arg, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.<span class="title function_">nextTick</span>(</span><br><span class="line">      callback,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;argument should be string&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码做了一个参数检查，如果不正确，它会把错误传递到回调。最近对API进行了更新，允许传递参数给<code>process.nextTick()</code>，回调函数之后可以接收任意参数，这些参数会传给回调函数作为参数，这样就不必嵌套函数了。</p>
<p>我们做的是，在允许用户的剩余代码执行后，把错误传回给用户。通过使用<code>process.nextTick()</code>，我们保证了<code>apiCall()</code>总是在用户的剩余代码<em>之后</em>，事件循环继续<em>之前</em> 执行它的回调函数。为了实现这个，JS的调用栈允许<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2331316/what-is-stack-unwinding">栈展开</a>然后立即执行提供的回调，该回调允许递归调用<code>process.nextTick()</code>而不会造成<code>RangeError: Maximum call stack size exceeded from V8</code>.</p>
<p>这种理念可能导致一些潜在的问题情况。如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this has an asynchronous signature, but cals callback synchronously</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someAsyncApiCall</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the callback is called before `someAsyncApiCall` completes.</span></span><br><span class="line"><span class="title function_">someAsyncApiCall</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// since someAsyncApiCall hasn&#x27;t completed, bar hasn&#x27;t been assigned any value</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>, bar); <span class="comment">// undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>用户定义了<code>someAsyncApiCall()</code> ，为异步签名，但是实际上是同步地操作。当调用时，提供给<code>someAsyncApiCall()</code>的回调在事件循环的同意阶段调用了，因为<code>someAsyncApiCall()</code>实际上并没有做任何异步的操作。结果就是，回调试图引用<code>bar</code>，即使在作用域中可能没有该变量，因为代码未能运行完成。</p>
<p>通过将代码放入<code>process.nextTick()</code>，代码就有能力运行完成了，允许所有的变量、函数等等，在回调函数被调用之前先初始化。这还有个优势：不允许事件循环继续。对于用户来说，在事件循环继续之前，提醒错误可能有帮助。这是使用<code>process.nextTick()</code>后的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someAsyncApiCall</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  process.<span class="title function_">nextTick</span>(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncApiCall</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>, bar)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>现实中的另一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = net.<span class="title function_">createServer</span>(<span class="function">() =&gt;</span> &#123;&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>当只传递一个端口时，该端口立即被绑定。所以，<code>&#39;listening&#39;</code>回调可能立即被调用，问题在于那时<code>.on(&#39;listening&#39;)</code> 回调可能还没有设置。</p>
<p>为了避免这个问题，<code>&#39;listening&#39;</code>事件入队到<code>nextTick()</code>，来允许脚本运行到完成。这就允许用户去设置任何他们想要的事件处理器。</p>
<h5 id="process-nextTick-VS-setImmediate"><a href="#process-nextTick-VS-setImmediate" class="headerlink" title="process.nextTick() VS setImmediate()"></a><code>process.nextTick()</code> VS <code>setImmediate()</code></h5><p>我们有两个相似的调用，但是它们的名字很让人困惑。</p>
<ul>
<li><p><code>process.nextTick()</code>在同一阶段立即触发</p>
</li>
<li><p><code>setImmediate()</code>在事件循环之后的迭代或’tick’触发</p>
</li>
</ul>
<p>本质上，名称应该交换一下。<code>process.nextTick()</code> 比 <code>setImmediate()</code>触发的更快，但这是历史遗留问题，不可能改变。做这个转换会破坏npm上的大部分packages.每天都有新的模块添加，意味着我们每等一天，更多的潜在破坏会发生。虽然让门令人困惑，到那时名称本身不会变。</p>
<blockquote>
<p>我们推荐开发者在所有情况下都使用<code>setImmediate()</code>，因为更容易理解。</p>
</blockquote>
<h4 id="为什么使用process-nextTick"><a href="#为什么使用process-nextTick" class="headerlink" title="为什么使用process.nextTick()?"></a>为什么使用<code>process.nextTick()</code>?</h4><p>有两个重要的原因：</p>
<ol>
<li>允许用户处理错误，清除任何不需要的资源，或者在事件循环继续之前再次尝试请求</li>
<li>当需要在调用栈展开之后但是事件循环继续之前运行回调时</li>
</ol>
<p>一个例子就是匹配用户的期望。相似的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = net.<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">conn</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>假设<code>listen()</code>在事件循环的开始处运行，但是listening回调放在<code>setImmediate()</code>中。除非传递了主机名，否则绑定到端口会立即发生。因为事件循环要继续，必定进入<strong>poll</strong>阶段，这意味着在listening事件之前，有机会接收到连接，触发connection事件。</p>
<p>另一个例子是，扩展<code>EventEmitter</code>并在constructor中触发一个事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line">myEmitter.<span class="title function_">on</span>(<span class="string">&#x27;evemt&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;an event occured!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>你不可能在constructor立即触发一个事件，因为脚本还没处理到用户赋值回调给那个事件的地方。所以，在constructor，你可以使用<code>process.nextTick()</code>来设置一个回调，在constructor完成之后触发该事件。结果如预期：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line">myEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;an event occured!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-01</span><i class="fa fa-tag"></i><a class="tag" href="/tags/NodeJS/" title="NodeJS">NodeJS </a><a class="tag" href="/tags/Event-Loop/" title="Event Loop">Event Loop </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2019/05/01/NodeJS事件循环/,Feymann,NodeJS事件循环,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/08/07/JS%E9%97%AD%E5%8C%85/" title="JS闭包的底层运行机制">上一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Feymann"><title>JS闭包的底层运行机制 · Feymann</title><meta name="description" content="JS闭包的底层运行机制
我已经使用闭包很长时间了，我学会了如何使用它，但是对于闭包怎样工作，幕后发生了什么，我并没有透彻的理解。闭包到底是个什么？维基没有帮到什么忙。当闭包创建与删除时，应该是怎样实现的？
1234567891011121314151617&amp;quot;use strict&amp;quot;"><meta name="keywords" content="Blog, web, fullstack, Typescript"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 7.0.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:127px;"><h3 title=""><a href="/">Feymann</a></h3><div class="description"><p>A programmer</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/wydumn"><i class="fa fa-github"></i></a></li></ul><div class="footer"><div class="p"> <span>©  </span><i class="fa fa-star"></i><span> Feymann</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>JS闭包的底层运行机制</a></h3></div><div class="post-content"><h1 id="JS闭包的底层运行机制"><a href="#JS闭包的底层运行机制" class="headerlink" title="JS闭包的底层运行机制"></a><a target="_blank" rel="noopener" href="https://dmitryfrank.com/articles/js_closures">JS闭包的底层运行机制</a></h1><hr>
<p>我已经使用闭包很长时间了，我学会了如何使用它，但是对于闭包怎样工作，幕后发生了什么，我并没有透彻的理解。闭包到底是个什么？维基没有帮到什么忙。当闭包创建与删除时，应该是怎样实现的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> myClosure = (<span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hidden = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">inc</span>: <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hidden++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">myClosure.<span class="title function_">inc</span>();    <span class="comment">// return 1</span></span><br><span class="line">myClosure.<span class="title function_">inc</span>();    <span class="comment">// return 2</span></span><br><span class="line">myClosure.<span class="title function_">inc</span>();    <span class="comment">// return 3</span></span><br><span class="line"><span class="comment">// OK, very nice.但是这是怎么实现的，背后发生了什么</span></span><br></pre></td></tr></table></figure>

<p>当我最终搞清楚后，我非常兴奋决定向大家解释一下：至少我现在绝对不会忘了。</p>
<blockquote>
<p>Tell me and I forget. Teach me and I remember. Invoke me and I learn.<br>Benjamin Franklin</p>
</blockquote>
<p>当我在阅读现有的对闭包的解释时，我竭力将闭包与其他东西形象地关联起来的：哪一个对象引用了其他对象，哪一个对象继承了另一个对象，等等。我没找到想要的插图效果，所以我还是自己画吧。</p>
<p>我假设儒者都已经熟悉JavaScript，知道什么是全局对象(Global Object)，知道在JS中，函数是“一等公民”，等等。</p>
<h2 id="作用域链-Scope-chain"><a href="#作用域链-Scope-chain" class="headerlink" title="作用域链(Scope chain)"></a>作用域链(Scope chain)</h2><p>当JS代码在执行时，需要一些空间来存储局部变量(local variables).我们就把这些空间称为作用域对象(scope object， 也有人称之为词法环境(Lexical Environment))。比如，当你调用一些函数时，被调函数定义了局部变量，这些变量保存在作用域对象中。你可以把作用域对象看作一个普通对象，但是不能对其进行直接引用；你只能修改它的属性，但不能引用作用域对象本身。</p>
<p>这里，作用域对象的概念，与C或者C++将局部变量存储在栈中不同，JS中作用域对象被分配在堆内存中（至少表现出来是这样），所以即使函数已经返回，它们也可能保持分配状态。稍后再谈。</p>
<p>如你所望，作用域对象可能有父作用域对象(parent scope chain)。当代码要访问一些变量时，解释器查找当前作用域对象的属性，若属性不存在，解释器会到父作用域对象中查找，如果还没有，到父作用域对象的父作用域对象中查找，直到找到或没有父作用域对象为止。我们将这个线性查找过程中的作用域对象序列称之为作用域链。</p>
<p>在作用域链上查找变量的过程和原型链上查找属性的过程很相似，但有一点不同：当你要访问普通对象中并不存在的属性时，且这个属性在作用域链中也没有，它并不会报错，只是返回一个undefined。但你要是在作用域链中访问一个不存在的属性（即不存在的变量），那就会抛出ReferenceError.</p>
<p>作用域链中的最后一个查找的作用域对象就是全局对象(Global Object)。在JS的top-level code（最外层代码）中，作用域链中只有一个对象：全局对象。所以，当在最外层代码中定义变量，他们就定义在了全局对象上。当有函数调用时，作用域链就加入了多个作用域对象。你可能以为当一个函数在最外层代码被调用时，作用域链一定只有两个作用域对象，但这不是真的。因为可能有2个或多个，取决于具体情况。下面详解。</p>
<h2 id="Top-level-code"><a href="#Top-level-code" class="headerlink" title="Top-level code"></a>Top-level code</h2><p>理论扯得够多了，我们来看点儿具体案例。下面是一个很简单的<code>my_scripts.js</code>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在最外层代码中我们创建了两个变量。我之前说过，对于最外层代码，作用域对象就是全局对象：</p>
<p><img src="/images/closure/closure1.png"></p>
<p>在上图中，有一个执行上下文（也就是最外层的<code>my_scripts.js</code>代码），它引用了作用域对象。当然，全局对象中还有许多其他的东西没有画在图中。</p>
<h2 id="非嵌套函数"><a href="#非嵌套函数" class="headerlink" title="非嵌套函数"></a>非嵌套函数</h2><p>考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//-- define local-to-function variables</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;inside myFunc&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;outside&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- and then, call it;</span></span><br><span class="line"><span class="title function_">myFunc</span>()</span><br></pre></td></tr></table></figure>

<p>当定义了<code>myFunc</code>函数后，<code>myFunc</code>标识符就添加到了当前作用域对象中（本例中就是全局对象），这个标识符引用的是**函数对象(function object)<strong>。这个函数对象包含了函数的代码字符串和一些其他属性。这些属性中我们要关注的是内部属性<code>[[scope]]</code>，它指向了</strong>当前作用域对象(current scope object)**，也就是，当函数被定义时，处于活动状态的作用域对象（本例中，就是全局对象）。</p>
<blockquote>
<p>活动状态，就是作用域链查找时，第一个访问到的作用域对象，不用再向下查找。（《JS高级程序设计》里面的活动对象active object，作用域对象就是变量对象(variable object)，到了执行阶段，处于活动状态的变量对象就是活动对象(active object)）</p>
</blockquote>
<p>所以，到<code>console.log(&quot;outside&quot;);</code>被执行时，我们就有了下面的情况：</p>
<p><img src="/images/closure/closure2.png"></p>
<p>我们来看一下：<code>myFunc</code>变量引用的函数对象不仅包含了函数代码，被引用的函数对象还指向函数定义时的作用域对象（图中<code>[[scope]]</code>表示，也就是<code>Global object</code>）。<strong>这非常重要！</strong></p>
<p>当函数被调用时，创建新的作用域对象。新创建的作用域对象，继承自被调函数引用的作用域对象，并且包含了<code>myFunc</code>的局部变量（以及它的参数值）。</p>
<p>所以，当实际调用<code>myFunc</code>时，如下：</p>
<p><img src="/images/closure/closure3.png"></p>
<p>现在我们就有了一个作用域链：如果想要访问<code>myFunc</code>中的变量，JS将会在第一个作用域对象：<code>myFunc() scope</code>中查找。如果没有找到，就到作用域链的下一个作用域对象中（这里就是<code>Global object</code>）查找。如果要找的属性在作用域链中并没有，就抛出<code>ReferenceError</code>.</p>
<p>例如，我们访问myFunc中的<code>a</code>，就会从第一个作用域对象<code>myFunc() scope</code>中得到<code>1</code>。如果要访问<code>foo</code>，会在<code>myFunc() scope</code>中得到<code>3</code>，不用再到<code>Global object</code>中找了。如果访问<code>bar</code>，会从<code>Global object</code>中得到<code>2</code>。查找的机制和原型继承非常像。</p>
<p>需要注意的是，只要有对这些作用域对象的引用，这些作用域对象就会保存在内存中。当解除对某个作用域对象的最后一个引用时，可以对该作用域对象进行垃圾回收（但不一定立刻被回收）。</p>
<p>所以，当<code>myFunc()</code>返回，且没有对<code>myFunc() scope</code>的引用时，它会被垃圾回收。所以我们又回到之前的状态：</p>
<p><img src="/images/closure/closure4.png"></p>
<p>从现在起，我将不再在图中画出函数对象。但记得：在JavaScript中对函数的任何引用都指向函数对象，而函数对象又引用作用域对象。</p>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>正如我们在前面的讨论中看到的，当函数返回后，没有引用作用域对象，因此，它会被垃圾回收。但是，如果我们定义嵌套函数并返回它（或存储在外部某处），会怎么样呢？您已经知道：函数对象总是指向它创建时的作用域对象。因此，当我们定义嵌套函数时，它会获得对外部函数的当前作用域对象的引用。如果我们将这个嵌套函数存储在外部某个地方，那么即使在外部函数返回后，作用域对象也不会被垃圾回收：仍然保持对它的引用！请考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">    <span class="comment">//-- define local-to-function variables</span></span><br><span class="line">    <span class="keyword">var</span> counter = initial</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- define nested functions. Each of them will have</span></span><br><span class="line">    <span class="comment">//   a reference to the current scope object</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increments internal counters by given value</span></span><br><span class="line"><span class="comment">     * If given value is not a finite number or is less  than 1, then 1 is used</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isFinite</span>(value) || value &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            value = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        counter += value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return current counter value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> counter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-- return object containing references</span></span><br><span class="line">    <span class="comment">//   to nested function</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">increment</span>: increment,</span><br><span class="line">        <span class="attr">get</span>: get</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- create counter object</span></span><br><span class="line"><span class="keyword">var</span> myCounter = <span class="title function_">createCounter</span>(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCounter.<span class="title function_">get</span>())    <span class="comment">//-- prints &quot;100&quot;</span></span><br><span class="line"></span><br><span class="line">myCounter.<span class="title function_">increment</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCounter.<span class="title function_">get</span>())    <span class="comment">//-- prints &quot;105&quot;</span></span><br></pre></td></tr></table></figure>

<p>当我们调用<code>createCounter(100)</code>时，有如下操作：</p>
<p><img src="/images/closure/closure_4.png"></p>
<p>注意，<code>createCounter(100) scope</code>被嵌套函数<code>increment</code>和<code>get</code>引用。如果<code>createCounter()</code>没有返回任何内容，当然，这些内部自引用也就不会被包含在内，那么无论如何<code>createCounter(100) scope</code>都会被垃圾回收。但是由于<code>createCounter()</code>返回的对象包含对这些函数的引用，因此有以下内容：</p>
<p><img src="/images/closure/closure6.png"></p>
<p>花点时间思考一下：<code>createCounter(100)</code>函数已经返回，但是它的作用域仍然存在，可以由内部函数访问，而且只能由这些函数访问。我们不能直接访问<code>createCounter(100) scope</code>对象，只能调用<code>myCounter.increment()</code>或<code>myCounter.get()</code>。这些函数对<code>createCounter</code>的作用域具有唯一的私有访问权。</p>
<p>让我们尝试调用，例如<code>myCounter.get()</code>。回想一下，当调用任何函数时，都会创建新的作用域对象，并且由该函数引用的作用域链会用这个新的作用域对象进行扩充。所以，当调用<code>myCounter.get()</code>时，情况如下：</p>
<p><img src="/images/closure/closure7.png"></p>
<p>函数<code>get()</code>的作用域链的第一个作用域对象是空对象<code>get() scope</code>。因此，当<code>get()</code>访问<code>counter</code>变量时，JavaScript无法在作用域链的第一个对象上找到它，进而到下一个作用域对象，并在<code>createCounter(100) scope</code>上使用<code>counter</code>变量。然后函数<code>get()</code>返回它的值。</p>
<p>你可能已经注意到<code>myCounter</code>对象还作为<code>this</code>给到了函数<code>myCounter.get()</code>（在图中用红色箭头表示）。这是因为<code>this</code>从来都不是作用链的一部分，应该意识到这一点。后面会谈到<code>this</code>。</p>
<p>调用<code>increment(5)</code>比较有趣，因为这个函数有一个参数：</p>
<p><img src="/images/closure/closure8.png"></p>
<p>如上图，参数<code>value</code>存储在调用<code>increment(5)</code>创建的作用域对象中。当此函数访问<code>value</code>值时，JavaScript立即在作用域链中的第一个对象上找到它。但是，当函数访问<code>counter</code>时，JavaScript无法在作用域链中的第一个对象上找到它，进而到下一个作用域对象，并在那里找到它。因此，<code>increment()</code>修改了<code>createCounter(100) scope</code>上的<code>counter</code>变量。实际上没有人能修改这个变量。 This is why closures are so powerful: the <code>myCounter</code> object is impossible to compromise. Closures are very appropriate place to store private things.</p>
<p>注意，即使未使用到参数<code>initial</code>，它也被存储在作用域对象<code>createCounter()</code>中。因此，如果去掉显式的<code>var counter = initial</code>，将<code>initial</code>重命名为<code>counter</code>，并直接使用它，我们可以节省一些内存。但是，为了可读性，我们使用参数<code>initial</code>和<code>var counter</code>。</p>
<p>重要的是绑定作用域是“活动的”。函数调用时，不会为此函数拷贝当前的作用域链，而是用新的作用域对象扩展当前作用域链，当链中的任何作用域对象被任何函数修改时，此更改将立即被其作用域链中包含此作用域对象的所有函数观察到。当<code>increment()</code>修改<code>counter</code>值时，对<code>get()</code>的下一次调用将返回更新的值。</p>
<p>这就是为什么这个众所周知的例子不起作用（所有<code>this.innerHTML</code>的i值都为<code>elems.length</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, elems = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;myClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elems.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    elems[i].<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = i;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环中创建了多个函数，所有这些函数都引用了其作用域链中的同一作用域对象。所以，它们使用完全相同的变量<code>i</code>，而不是它的私有副本。有关此例的进一步解释，请参见此链接：<a target="_blank" rel="noopener" href="http://www6.jslinterrors.com/?tdfs=1&s_token=1581848248.0032985258&uuid=1581848248.0032985258&kw=Javascript&term=JSLint%20Online%20Learning%20Management%20System&term=Online%20Javascript%20Courses&term=Web%20App%20Performance%20Testing&backfill=0">Don’t make functions within a loop</a>.</p>
<h2 id="相似的函数对象，不同的作用域对象"><a href="#相似的函数对象，不同的作用域对象" class="headerlink" title="相似的函数对象，不同的作用域对象"></a>相似的函数对象，不同的作用域对象</h2><p>现在，我们试着扩展一点我们的<code>counter</code>例子，来找点乐子。如果我们创建多个<code>counter</code>对象呢：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... see the code from previous example */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- create counter objects</span></span><br><span class="line"><span class="keyword">var</span> myCounter1 = <span class="title function_">createCounter</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> myCounter2 = <span class="title function_">createCounter</span>(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>创建<code>myCounter1</code>和<code>myCounter2</code>时，我们有以下内容：</p>
<p><img src="/images/closure/closure9.png"></p>
<p>牢记，每个函数对象都有对作用域对象的引用。因此，在上面的示例中，<code>myCounter1.increment</code>和<code>myCounter2.increment</code>引用的函数对象具有完全<strong>相同的代码</strong>和相同的属性值（<code>name</code>、<code>length</code>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#Function_prototype_object">其他</a>），但它们的<code>[[scope]]</code>引用的是<strong>不同的作用域对象</strong>。</p>
<p>为了简单起见，图中没有包含单独的函数对象，但它们仍然存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a = myCounter1.<span class="title function_">get</span>()    <span class="comment">// a equals 100</span></span><br><span class="line">b = myCounter2.<span class="title function_">get</span>()    <span class="comment">// b equals 200</span></span><br><span class="line"></span><br><span class="line">myCounter1.<span class="title function_">increment</span>(<span class="number">1</span>)</span><br><span class="line">myCounter1.<span class="title function_">increment</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">myCounter1.<span class="title function_">increment</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">a = myCounter1.<span class="title function_">get</span>()    <span class="comment">// a equals 103</span></span><br><span class="line">b = myCounter2.<span class="title function_">get</span>()    <span class="comment">// b equals 205</span></span><br></pre></td></tr></table></figure>
<p>所以，这就是它的工作原理。闭包的概念非常强大。</p>
<h2 id="作用域链和”this”"><a href="#作用域链和”this”" class="headerlink" title="作用域链和”this”"></a>作用域链和”this”</h2><p>不管你喜不喜欢，<code>this</code>不是作为作用域链的一部分保存的。相反，<code>this</code>的值取决于函数调用模式：也就是说，您可以用不同的<code>this</code>值调用相同的函数。</p>
<h3 id="调用模式"><a href="#调用模式" class="headerlink" title="调用模式"></a>调用模式</h3><p>这个主题非常值得再写一篇文章，所以我不会深入讨论，但是作为一个快速的概述，有四种调用模式。我们开始吧：</p>
<ol>
<li><p>方法调用模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="attr">myProp</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">myFunc</span>: <span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">myProp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObj.<span class="title function_">myFunc</span>()  <span class="comment">//-- returned 100</span></span><br></pre></td></tr></table></figure>
<p>如果调用表达式包含refinement（点或<code>[下标]</code>），则函数将作为方法调用。所以，在上面的例子中，<code>this</code>给<code>myFunc()</code>的是对<code>myObj</code>的引用。</p>
</li>
<li><p>函数调用模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">myFunc</span>()    <span class="comment">//-- returns undefined</span></span><br></pre></td></tr></table></figure>
<p>如果没有refinement，则取决于代码是否在严格模式下运行：</p>
<ul>
<li>在严格模式下，<code>this</code>是<code>undefined</code></li>
<li>非严格模式下，<code>this</code>指向Global Object</li>
</ul>
</li>
<li><p>构造函数调用模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Myobj</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">b</span> = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="title class_">MyObj</span>()</span><br></pre></td></tr></table></figure>
<p>当使用<code>new</code>前缀调用函数时，JavaScripts会分配继承自函数<code>prototype</code>属性的新对象，而这个新分配的对象就作为<code>this</code>分配给函数。</p>
</li>
<li><p>Apply调用模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params">myArg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">myProp</span> + <span class="string">&quot; &quot;</span> + myArg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = myFunc.<span class="title function_">apply</span>(</span><br><span class="line">    &#123; <span class="attr">myPtop</span>: <span class="string">&quot;prop&quot;</span> &#125;,</span><br><span class="line">    [ <span class="string">&quot;arg&quot;</span> ]</span><br><span class="line">)</span><br><span class="line"><span class="comment">//-- result is &quot;prop arg&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以用任意值作为<code>this</code>传递。在上面的例子中，我们使用了<code>Function.prototype.apply()</code>函数。除此之外，也可以用：</p>
<ul>
<li><code>Function.prototype.call()</code></li>
<li><code>Function.prototype.call()</code><br>下面的例子中，我们主要用方法调用模式。</li>
</ul>
</li>
</ol>
<h2 id="嵌套函数中”this”的用法"><a href="#嵌套函数中”this”的用法" class="headerlink" title="嵌套函数中”this”的用法"></a>嵌套函数中”this”的用法</h2><p>考虑如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">myProp</span>: <span class="string">&quot;outer-value&quot;</span>,</span><br><span class="line">    <span class="attr">createInnerObj</span>: <span class="keyword">function</span> <span class="title function_">createInnerObj</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> hidden = <span class="string">&quot;value-in-closure&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">myProp</span>: <span class="string">&quot;inner-value&quot;</span>,</span><br><span class="line">            <span class="attr">innerFunc</span>: <span class="keyword">function</span> <span class="title function_">innerFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;hidden: &quot;</span> + hidden + <span class="string">&quot;&#x27;, myProp: &#x27;&quot;</span> + <span class="variable language_">this</span>.<span class="property">myProp</span> + <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myInnerObj = myObj.<span class="title function_">createInnerObj</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( myInnerObj.<span class="title function_">innerFunc</span>() )</span><br></pre></td></tr></table></figure>
<p>输出：<code>hidden: value-in-closure&#39;, myProp: &#39;inner-value&#39;</code></p>
<p>在调用<code>myObj.createInnerObj()</code>时：</p>
<p><img src="/images/closure/closure10.png"></p>
<p>当我们调用<code>myInnerObj.innerFunc()</code>时，它如下所示：</p>
<p><img src="/images/closure/closure11.png"></p>
<p>从上面可以清楚地看出，给到<code>myObj.createInnerObj()</code>的<code>this</code>指向了<code>myObj</code>，而给到<code>myInnerObj.innerFunc()</code>的<code>this</code>指向<code>myInnerObj</code>：这两个函数都是用方法调用模式调用的，如上所述。这就是为什么<code>innerFunc()</code>中的<code>this.myProp</code> 的计算结果是<code>&quot;inner-value&quot;</code>，而不是<code>&quot;outer-value&quot;</code>。</p>
<p>所以，我们可以使用不同的<code>myProp</code>简单地欺骗<code>innerFun()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... see the definition of myObj above ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myInnerObj = myObj.<span class="title function_">createInnerObj</span>();</span><br><span class="line"><span class="keyword">var</span> fakeObject = &#123;</span><br><span class="line">  <span class="attr">myProp</span>: <span class="string">&quot;fake-inner-value&quot;</span>,</span><br><span class="line">  <span class="attr">innerFunc</span>: myInnerObj.<span class="property">innerFunc</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fakeObject.<span class="title function_">innerFunc</span>() );</span><br></pre></td></tr></table></figure>
<p>输出：<code>hidden: &#39;value-in-closure&#39;, myProp: &#39;fake-inner-value&#39;</code></p>
<p><img src="/images/closure/closure12.png"></p>
<p>或者使用<code>apply()</code>或<code>call()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... see the definition of myObj above ... */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> myInnerObj = myObj.<span class="title function_">createInnerObj</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  myInnerObj.<span class="property">innerFunc</span>.<span class="title function_">call</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">myProp</span>: <span class="string">&quot;fake-inner-value-2&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>输出：<code>hidden: &#39;value-in-closure&#39;, myProp: &#39;fake-inner-value-2&#39;</code></p>
<p>然而，有时内部函数实际上需要访问外部函数的<code>this</code>，而与调用内部函数的方式无关。有一个常见的习惯用法：我们需要在闭包中显式保存所需的值（即，在当前作用域对象中），如：<code>var self = this;</code>，并在内部函数中使用<code>self</code>，而不是<code>this</code>。考虑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="attr">myProp</span>: <span class="string">&quot;outer-value&quot;</span>,</span><br><span class="line">  <span class="attr">createInnerObj</span>: <span class="keyword">function</span> <span class="title function_">createInnerObj</span>(<span class="params"></span>) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> hidden = <span class="string">&quot;value-in-closure&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">myProp</span>: <span class="string">&quot;inner-value&quot;</span>,</span><br><span class="line">      <span class="attr">innerFunc</span>: <span class="keyword">function</span> <span class="title function_">innerFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hidden: &#x27;&quot;</span> + hidden + <span class="string">&quot;&#x27;, myProp: &#x27;&quot;</span> + self.<span class="property">myProp</span> + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> myInnerObj = myObj.<span class="title function_">createInnerObj</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( myInnerObj.<span class="title function_">innerFunc</span>() );</span><br></pre></td></tr></table></figure>
<p>输出：<code>hidden: &#39;value-in-closure&#39;, myProp: &#39;outer-value&#39;</code></p>
<p>这样，我们有如下：</p>
<p><img src="/images/closure/closure13.png"></p>
<p>如上图，这次，<code>innerFunc()</code>通过闭包中存储的<code>self</code>，可以访问到外部函数的<code>this</code>值。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>让我们回答在文章开头的几个问题：</p>
<ul>
<li>什么是闭包？-它是同时引用函数对象和作用域对象的对象。实际上，所有JavaScript函数都是闭包：没有作用域对象就不可能有对函数对象的引用。</li>
<li>它是什么时候创建的？-因为所有的JavaScript函数都是闭包，所以很明显：当定义一个函数时，实际上定义了一个闭包。因此，它是在定义函数时创建的。但要确保区分闭包创建和新作用域对象创建：定义函数时创建闭包（函数+对当前作用域链的引用），调用函数时创建新作用域对象（并用于扩展闭包的作用域链）。</li>
<li>什么时候删除？-就像JavaScript中的任何普通对象一样，当没有对它的引用时，它会被垃圾回收。</li>
</ul>
<p>进一步阅读：</p>
<ul>
<li>JavaScript: The Good Parts 作者Douglas Crockford。理解闭包是如何工作的当然很好，但理解如何正确使用它们可能更重要。这本书非常简洁，里面有许多伟大且有用的模式。</li>
<li>JavaScript: The Definitive Guide 作者David Flanagan。顾名思义，这本书以非常详细的方式解释了语言。</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-08-07</span><i class="fa fa-tag"></i><a class="tag" href="/tags/javascript/" title="javascript">javascript </a><a class="tag" href="/tags/closure/" title="closure">closure </a><a class="tag" href="/tags/翻译/" title="翻译">翻译 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2019/08/07/JS闭包/,Feymann,JS闭包的底层运行机制,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/01/20/Authentication/" title="Authentication">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/05/01/NodeJS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" title="NodeJS事件循环">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>